# 2.3.2. Анализ и оптимизация запроса 2.3.1 и схемы БД

## Анализ запроса

Запрос `top_5_products_last_month` выполняет: JOIN order_products → orders, products, categories (категория товара и корневая по `root_category_id`), фильтрацию по дате (последний календарный месяц), группировку по товару, сортировку и LIMIT 5.

**Узкие места при росте данных (тысячи заказов в день):**
- Многостроенные JOIN по order_products, orders, products, categories — при отсутствии индексов на ключах соединения время растёт.
- Агрегация и сортировка по большому объёму строк до LIMIT 5.

## Оптимизация запроса

- **Параметризация:** передавать границы периода (начало/конец месяца) в запрос из приложения — стабильное использование индекса по `orders.created_at`.
- **Индексы для JOIN:** добавить индексы на `order_products(order_id)` и `order_products(product_id)` — в текущей схеме их нет (есть только уникальное ограничение по паре). Ускоряют соединения в отчёте.
- **Материализованное представление:** хранить результат топ-5 за месяц в MATERIALIZED VIEW и обновлять по расписанию в виде фоновой задачи.

## Оптимизация схемы данных

- **Индексы:** добавить только то, чего нет в миграции: индексы на `order_products.order_id` и `order_products.product_id`; при необходимости — составной `order_products(order_id, product_id)` и составной `orders(created_at, status)`.
- **Партиционирование orders** — при очень больших объёмах разбить таблицу заказов по диапазону `created_at` (например, по неделям, месяцам или кварталам), чтобы отчёты за период затрагивали меньше данных.
- **Кэш в приложении** — кэшировать результат топ-5 (Redis) с TTL или инвалидацией при новых заказах.

## Приоритеты

1. Добавить индексы на order_products (order_id, product_id).
2. Внедрить MATERIALIZED VIEW для топ-5 с периодическим REFRESH.
3. При дальнейшем росте — партиционирование orders и кэширование на уровне приложения.
